<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2021" />
<meta name="DC.rights.owner" content="(C) Copyright 2021" />
<meta name="DC.Type" content="ConceptTopic" />
<meta name="DC.Title" content="Example Device Annotation Programs Using DFM Property" />
<meta name="abstract" content="The Device Annotation Built-In Language provides a means for combining DFM Property measurements with devices recognized using Calibre nmLVS. DFM Property is an efficient and versatile operation for collecting and combining complex device property measurements used in parasitic extraction flows." />
<meta name="description" content="The Device Annotation Built-In Language provides a means for combining DFM Property measurements with devices recognized using Calibre nmLVS. DFM Property is an efficient and versatile operation for collecting and combining complex device property measurements used in parasitic extraction flows." />
<meta name="prodname" content="Standard Verification Rule Format (SVRF) Manual" />
<meta name="version" content="2014.06" />
<meta name="release" content="v2014.06" />
<meta name="series" content="mgc_ih" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Publisher" content="Siemens Industry Software 10 24 2014 10 24 2014 Fresh off the boat." />
<meta name="DC.Date.Created" content="0000-00-00" />
<meta name="DC.Date.Modified" content="2021-03-26" />
<meta name="Topline" content="Siemens EDA" />
<meta name="VariantPrefix" content="none" />
<meta name="IncludeDraftCommentsInChangeLog" content="21.2" />
<meta name="HighlightColor" content="mgc_yellow_129_50" />
<meta name="HighlightChanges" content="yes" />
<meta name="GenerateOnlyChangedTopics" content="none" />
<meta name="Tier" content="1" />
<meta name="SubTitle" content="none" />
<meta name="SourceHandle" content="svrf_ur" />
<meta name="SoftwareVersionNum" content="2021.2" />
<meta name="SoftwareRelease" content="none" />
<meta name="RevHist" content="14" />
<meta name="PublicationDate" content="none" />
<meta name="Platform" content="none" />
<meta name="PartNumber" content="none" />
<meta name="LicenseType" content="EULA" />
<meta name="InfoHubHandle" content="calbr_ih" />
<meta name="EclipsePluginName" content="none" />
<meta name="DraftDate" content="3/25/21" />
<meta name="Draft" content="none" />
<meta name="DocumentTitle" content="Standard Verification Rule Format (SVRF) Manual" />
<meta name="CSHelp" content="No" />
<meta name="CSDSearchKeywords" content="doc.type.documentation.ref,product.version.v2021.2,product.id.P10089,product.id.P10099,product.id.P10119,product.id.P10101,product.id.P11427,product.id.P10115,product.id.P11426,product.id.P10122,product.id.P11493" />
<meta name="ConditionFiltering" content="XML" />
<meta name="Copyright" content="READONLY - Use: copyrfirst and copyrlast" />
<meta name="ChecklinksRelease" content="calibre" />
<meta name="BookcaseHandle" content="none" />
<meta name="Beta" content="none" />
<meta name="Alpha" content="none" />
<meta name="ActiveStatus" content="Active" />
<meta name="IncludeInInventory" content="yes" />
<meta name="SourceEDDVersion" content="12.2.10" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="id834a8436-ffb5-42a8-a234-19c777df4304" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>Example Device Annotation Programs Using DFM Property</title>
<link rel="stylesheet" href="../../MGC/styles-disw/mgcdita-lang.css" type="text/css" /><noscript><link rel="StyleSheet" href="../../MGC/styles-disw/body.css" type="text/css" /><link rel="StyleSheet" href="../../MGC/styles-disw/catalog.css" type="text/css" /><link rel="StyleSheet" href="../../MGC/styles-disw/document.css" type="text/css" /><link rel="stylesheet" href="../../MGC/styles-disw/mgcdita-lang.css" type="text/css" /></noscript><meta name="mgc_html_doctitle" content="Example Device Annotation Programs Using DFM Property" />
<meta name="attributes" content="doc.type.documentation.ref,product.version.v2021.2,product.id.P10089,product.id.P10099,product.id.P10119,product.id.P10101,product.id.P11427,product.id.P10115,product.id.P11426,product.id.P10122,product.id.P11493" />
<meta name="TEMPLATEBASE" content="mgc_mgchelp_v4.3.000" />
<script type="text/javascript" language="JavaScript1.2" src="../../MGC/js/page.js"></script><script type="text/javascript" language="JavaScript1.2">
            if(DetectChromeForBasic()){
            writeNoScriptStyles();
            }

        </script><script type="text/javascript" language="JavaScript1.2">
            // Set reference to top level help frame
            //
            if(!DetectChromeForBasic()){
            javascriptTopicRedirect();
            }
        </script></head>
<body id="id834a8436-ffb5-42a8-a234-19c777df4304">
<div id="bodycontent" class="BodyContent">
<script type="text/javascript" language="JavaScript1.2">
              var BC = new Array("TODO: Breadcrumb Title","title1","naV","naV","naV","naV","2");
          </script>
<noscript><iframe framespacing="0" marginheight="2px" frameborder="no" scrolling="no" src="../../MGC/html/noscript_header.htm" width="100%" height="100px;">xxx</iframe></noscript>
<script type="text/javascript" language="JavaScript1.2">
              if(DetectChromeForBasic()){
              if(!(top.inEclipse)){
              writeBasicHeader();
              }
              }
          </script>
<div id="BodyContent"><h1 class="title topictitle1">Example Device Annotation Programs Using DFM Property</h1>
<div class="body conbody ConceptBody"><div class="abstract ConceptAbstract"><span class="shortdesc">The Device
Annotation Built-In Language provides a means for combining DFM
Property measurements with devices recognized using Calibre nmLVS.
DFM Property is an efficient and versatile operation for collecting
and combining complex device property measurements used in parasitic
extraction flows.</span>
</div>
<p class="p">All of the following examples
employ DFM properties to store device properties on derived layers.
See “<a class="xref fm:HeadingAndPage" href="MGCChap_DfmFunctionReference_idb886299e.html#idb886299e-a910-4a31-8840-7e7e48e9627e__MGCChap_DfmFunctionReference_idb886299e.xml#idb886299e-a910-4a31-8840-7e7e48e9627e" title="DFM functions are used within DFM expressions to create data used in classifying or producing layout objects. The functions are used in the DFM Property family of operations, DFM Analyze, DFM Function, and DFM Spec Fill Optimizer.">DFM Function Reference</a>” for complete details regarding DFM property functions.</p>
<p class="p">Netlists that combine these calculated properties
with the originally recognized devices are available through the
Query Server CCI interface. See “<a class="xref Link" href="../../calbr_query_user/nsmgchelp.htm" target="_top" onclick="oT('STD_FM11', 'Annotated Device Commands', 'calbr_query_user'); return false;">Annotated Device Commands</a>” in the <cite class="cite">Calibre Query Server Manual</cite> for
details.</p>
<div class="section Subsections" id="id834a8436-ffb5-42a8-a234-19c777df4304__idb4f09721-8239-4479-adf0-ec1a7a292db9"><div class="section Subsection" id="id834a8436-ffb5-42a8-a234-19c777df4304__idbf1a8d6d-1daa-4a5e-8897-c08c92186445"><h2 class="title Subheading sectiontitle">Example 1</h2><p class="p">The following code calculates AS and AD properties
(area of the source and drain pins) for an N-type MOSFET.</p>
<pre class="pre codeblock leveled"><code>DEV MN(n) ngate ngate(g) nsd(s) nsd(d) bulk(b)</code></pre><pre class="pre codeblock leveled"><code>// Get the area property from the source/drain pin layers:
nsd_wArea = DFM PROPERTY nsd [ A = AREA( nsd ) ]
// Accumulate pin area and pin net information onto the device seed shape:
NGate_all_asad = DFM PROPERTY (DEVICE LAYER MN) nsd_wArea 
                 OVERLAP ABUT ALSO MULTI
                 // net id of first s/d pin
                 [ N1 = NETID(nsd_wArea, 1) ]
                 // s/d pin shape count
                 [ C = COUNT(nsd_wArea) ]
    // total area for the first pin's net (area sum if pins are shorted)
                 [ AN1 = VNETSUM( NETID( nsd_wArea, 1 ), 
                         VNETID( NETID( nsd_wArea )), 
                         VECTOR(PROPERTY( nsd_wArea, A ))) 
                 ]
                 // area of the first s/d pin shape
                 [ AP1 = PROPERTY( nsd_wArea, A, 1 ) ]
                 // total area for all nsd pin shapes
                 [ ATotal = PROPERTY( nsd_wArea, A ) ]</code></pre><pre class="pre codeblock leveled"><code>// Transfer the AS and AD properties onto the recognized device.
DLAYER_MN_PROP = DEVICE LAYER MN(n) ANNOTATE NGate_all_asad
                 [ 
                  PROPERTY AS, AD
                  if ( PIN_NET(S) == PIN_NET(D) ) {
                  // shorted source/drain
                  // mimic the distribution done by Device recognition
                    if ( DFM_NUM_VAL(NGate_all_asad, "C") == 2 ) {
                  // two shorted s/d shapes
        // AS is area of first pin polygon; AD is total nsd area minus AS
                      AS = DFM_NUM_VAL(NGate_all_asad, "AP1")
                      AD = DFM_NUM_VAL(NGate_all_asad, "ATotal") - AS
                    } else {
                  // shorted s/d shape count other than 2
                  // AS is the total; assumption is there is only one pin
                      AS = DFM_NUM_VAL(NGate_all_asad, "ATotal")
                      AD = 0
                    }
                  } else {
                  // pins are not shorted
           if ( PIN_NET(S) == DFM_NUM_VAL(NGate_all_asad, "N1") ) {
                    // source pin has same net ID as property N1
                  // AS is the value of property AN1; AD is total minus AS
                    AS = DFM_NUM_VAL(NGate_all_asad, "AN1")
                    AD = DFM_NUM_VAL(NGate_all_asad, "ATotal") - AS
                    } else {
                    // drain pin has same net ID as property N1
                  // AD is the value of property AN1; AS is total minus AD
                       AD = DFM_NUM_VAL(NGate_all_asad, "AN1")
                       AS = DFM_NUM_VAL(NGate_all_asad, "ATotal") - AD
                    }
                  }
                  ]</code></pre><p class="p">The code for an MP device would be similar
to what is shown for MN devices. (Example 2 shows another form of
the DFM_NUMeric_VALue function that offers simpler coding in certain
cases.)</p>
<p class="p">Add these statements to the rule file:</p>
<pre class="pre codeblock leveled"><code>LVS ANNOTATE DEVICES DLAYER_MN_PROP
MASK SVDB DIRECTORY svdb QUERY CCI</code></pre><p class="p">When you run netlist extraction, the devices
are written without annotation properties. To get a netlist with
the annotation properties, you run Query Server CCI on the output.</p>
<p class="p">After opening the SVDB directory in Query
Server, you can then run CCI commands such as this excerpt:</p>
<pre class="pre codeblock leveled"><code>qs::set_gds_options -annotated_devices YES
qs::write_agf annotated_MN.agds
dfm::set_layout_netlist_options -annotated_devices YES
dfm::write_spice_netlist annotated_MN.sp
qs::quit</code></pre><p class="p">Using the command:</p>
<pre class="pre codeblock leveled"><code>% calibre -qs -svdb svdb -exec cci_script </code></pre><p class="p">the aforementioned commands used in a script
generate an annotated device layer map, an annotated device GDS
file, and an annotated device netlist.</p>
</div>
<div class="section Subsection" id="id834a8436-ffb5-42a8-a234-19c777df4304__idc00c85be-0afe-440f-babf-7c1260e3752a"><h2 class="title Subheading sectiontitle">Example 2</h2><p class="p">The Device Layer ANNOTATE program allows
assignment of a property based upon a DFM Property shape that overlaps
a device pin. This allows easier access to pin-specific properties that
are attached to DFM Property layers than is used in Example 1. The
dfm_numeric_value function’s <span class="ph FontProperty emphasis">pin_name</span> parameter
is used for this purpose.</p>
<p class="p">Consider the following example that attaches
AS and AD properties to a device layer:</p>
<pre class="pre codeblock leveled"><code>// unique device
DEVICE MN(nfet) nfet ngate(g) nsd(s) nsd(d) bulk(b)</code></pre><pre class="pre codeblock leveled"><code>// nsd_p overlaps nsd shapes
nsd_p = DFM PROPERTY nsd [ AREA = AREA(nsd) ]</code></pre><pre class="pre codeblock leveled"><code>mn1 = DEVICE LAYER MN(nfet) ANNOTATE nsd_p
      [
        PROPERTY AS, AD
        AS = DFM_NUM_VAL( nsd_p, AREA, s )
        AD = DFM_NUM_VAL( nsd_p, AREA, d )
      ]</code></pre><p class="p">Use of the <span class="keyword ParameterName OptionalReplaceable">pin_name</span> (third
argument to DFM_NUM_VAL) requires that the representative device
(type and optional subtype) for the Device Layer statement be unique.
In cases where the type and subtype are defined by more than one
Device statement, a DVL12 compiler error occurs.</p>
<p class="p">For example, the pin selection feature cannot
be used with the MN(n1) devices listed here:</p>
<pre class="pre codeblock leveled"><code>DEVICE MN(n1) NGATE NGATE1 SD SD BULK
DEVICE MN(n1) NGATE NGATE2 SD SD BULK1 BULK</code></pre><p class="p">It can be used if the model names are different:</p>
<pre class="pre codeblock leveled"><code>DEVICE MN(n1) NGATE NGATE1 SD SD BULK
DEVICE MN(n2) NGATE NGATE2 SD SD BULK1 BULK</code></pre><p class="p">The pin name specified must be valid for
the device being formed. For example, the statement:</p>
<pre class="pre codeblock leveled"><code>P1 = DFM_NUM_VAL( nsd_p, AREA, P1 )</code></pre><p class="p">for a device that lacks pin P1 produces a
DVL13 compiler error.</p>
</div>
<div class="section Subsection" id="id834a8436-ffb5-42a8-a234-19c777df4304__id5279d747-7ca0-41f0-b71b-e3119ee1c215"><h2 class="title Subheading sectiontitle">Example 3</h2><p class="p">This example shows the calculation of well
enclosure or stress effect (strained silicon) properties. This example
is based upon the method shown under “<a class="xref fm:HeadingAndPage" href="Concept_WellEnclosureStressEffectCalculationsDfmProperty_idc3cc8e33.html#idc3cc8e33-e128-402f-89e3-75857c21aee8__Concept_WellEnclosureStressEffectCalculationsDfmProperty_idc3cc8e33.xml#idc3cc8e33-e128-402f-89e3-75857c21aee8" title="The DFM Property operation is useful for calculating complex device properties. It allows attachment of values to polygons in order to report stress effect properties in a netlist.">Well Enclosure or Stress Effect Calculations with DFM Property</a>” and contains modifications
to that code for device annotation.</p>
<p class="p">The PAR and PER enclosure properties calculated
in this example are for MOS devices and are measured vertically
and horizontally from the “width” edges of gate polygons to the
enclosing well polygons. The device pin layers consist of ngate,
nsd, pwell, pgate, psd, and nwell.</p>
<pre class="pre codeblock leveled"><code>#! tvf

package require CalibreDFM_DEVICE 
namespace import tvf::// tvf::setlayer tvf::outlayer tvf::verbatim \tvf::rulecheck

verbatim {
// include layer definitions and connectivity rules.

// required for the LVS Annotate Devices flow
MASK SVDB DIRECTORY svdb QUERY CCI
LVS ANNOTATE DEVICES n_annot_layer
LVS ANNOTATE DEVICES p_annot_layer
}</code></pre><pre class="pre codeblock leveled"><code>// Globally set the maximum perpendicular and parallel enclosure 
// distances.
   set device::max_par 5.0
   set device::max_per 5.0</code></pre><pre class="pre codeblock leveled"><code>
// Define the gate enclosure property layers.
   setlayer ngate_prop.par = [ \
     device::enclosure_parallel_measurements -base ngate \
     -measurement pwell -orient nsd \
   ]

   setlayer ngate_prop.per = [ \
     device::enclosure_perpendicular_measurements -base ngate \
     -measurement pwell -orient nsd \
   ]

   setlayer pgate_prop.par = [ \
     device::enclosure_parallel_measurements -base pgate \
     -measurement nwell -orient psd \
   ]

   setlayer pgate_prop.per = [ \
     device::enclosure_perpendicular_measurements -base pgate \
     -measurement nwell -orient psd \
   ]</code></pre><pre class="pre codeblock"><code>// Define device orientation layers.
// 0.004 is arbitrary, but must be less than 0.5*seed polygon width.
   setlayer ngate_top = [ 
     device::select_top_device_edge ngate nsd 0.004
   ]

   setlayer ngate_bottom = [ 
     device::select_bottom_device_edge ngate nsd 0.004
   ]

   setlayer ngate_left = [ 
     device::select_left_device_edge ngate nsd 0.004
   ]

   setlayer ngate_right = [ 
     device::select_right_device_edge ngate nsd 0.004
   ]

   setlayer pgate_top = [ 
     device::select_top_device_edge pgate psd 0.004
   ]

   setlayer pgate_bottom = [ 
     device::select_bottom_device_edge pgate psd 0.004
   ]

   setlayer pgate_left = [ 
     device::select_left_device_edge pgate psd 0.004
   ]

   setlayer pgate_right = [ 
     device::select_right_device_edge pgate psd 0.004
   ]</code></pre><pre class="pre codeblock leveled"><code>
verbatim {
// Transfer enclosure vector properties onto gate edges.
ngate_top_p    = DFM PROPERTY ngate_top ngate_prop.par 
                 OVERLAP ABUT ALSO MULTI
                 [ PAR_top = VPROPERTY( ngate_prop.par, PAR ) ]
ngate_bottom_p = DFM PROPERTY ngate_bottom ngate_prop.par 
                 OVERLAP ABUT ALSO MULTI
                 [ PAR_bottom = VPROPERTY( ngate_prop.par, PAR ) ]
ngate_left_p   = DFM PROPERTY ngate_left ngate_prop.per 
                 OVERLAP ABUT ALSO MULTI
                 [ PER_left = VPROPERTY( ngate_prop.per,PER ) ]
ngate_right_p  = DFM PROPERTY ngate_right ngate_prop.per 
                 OVERLAP ABUT ALSO MULTI
               [ PER_right = VPROPERTY( ngate_prop.per, PER ) ]

pgate_top_p    = DFM PROPERTY pgate_top pgate_prop.par 
                 OVERLAP ABUT ALSO MULTI
                 [ PAR_top = VPROPERTY( pgate_prop.par, PAR ) ]
pgate_bottom_p = DFM PROPERTY pgate_bottom pgate_prop.par 
                 OVERLAP ABUT ALSO MULTI
                 [ PAR_bottom = VPROPERTY( pgate_prop.par, PAR ) ]
pgate_left_p   = DFM PROPERTY pgate_left pgate_prop.per 
                 OVERLAP ABUT ALSO MULTI
 [ PER_left =VPROPERTY( pgate_prop.per, PER ) ]
pgate_right_p  = DFM PROPERTY pgate_right pgate_prop.per 
                 OVERLAP ABUT ALSO MULTI
                 [ PER_right = VPROPERTY( pgate_prop.per, PER ) 
]</code></pre><pre class="pre codeblock leveled"><code>// This macro defines four enclosure measurement properties 
// for each device. The parA, parB, perA, and perB objects
// are stored with the DFM property layers that are passed in.
DMACRO mos_prop top bottom left right {
  [ 
    PROPERTY parA, parB, perA, perB
    W = DEVICE_NUMERIC_VALUE( "W" )
    L = DEVICE_NUMERIC_VALUE( "L" )
 // get the four vectors from the vector property layers.
    par_dfm_A = dfm_vector_value(top,"PAR_top")
    par_dfm_B = dfm_vec_val(bottom,"PAR_bottom")
    per_dfm_A = dfm_vec_val(left,"PER_left")
    per_dfm_B = dfm_vec_val(right,"PER_right")
// calculate the enclosure values on the four sides
// of the gate. 
    parA = tvf_num_fun::device_func::calc_eff_par(par_dfm_A, W, L, \
           unit_length())
    parB = tvf_num_fun::device_func::calc_eff_par(par_dfm_B, W, L, \
           unit_length())
    perA = tvf_num_fun::device_func::calc_eff_per(per_dfm_A, W, L, \
           unit_length())
    perB = tvf_num_fun::device_func::calc_eff_per(per_dfm_B, W, L, \
           unit_length())
  ]
}</code></pre><pre class="pre codeblock leveled"><code>// create the annotation layers
n_annot_layer = DEVICE LAYER MN 
     ANNOTATE ngate_top_p ngate_bottom_p ngate_left_p ngate_right_p
     CMACRO mos_prop ngate_top_p ngate_bottom_p ngate_left_p ngate_right_p
p_annot_layer = DEVICE LAYER MP 
     ANNOTATE pgate_top_p pgate_bottom_p pgate_left_p pgate_right_p
     CMACRO mos_prop pgate_top_p pgate_bottom_p pgate_left_p pgate_right_p</code></pre><pre class="pre codeblock leveled"><code>// calculate the enclosure property values
TVF FUNCTION device_func [/*
  package require CalibreLVS_DEVICE_DFM

  proc calc_eff_per { enc_prop W L unit_length } {
    set scale_factor [ $unit_length ]
    set enc_list [ device::scaled_dfm_vec_measurements $enc_prop \
                     $scale_factor ]
    set accum 0.0
    set half_L [ expr { 0.5 * [$L] } ]
    foreach segment $enc_list {
      foreach { width length } $segment {
        set seg [ expr { ($width / ( $length + $half_L )) } ]
        set accum [ expr { $accum + $seg } ]
      }
    }
    return [ expr { ( [$W] / $accum ) - $half_L } ]
  }</code></pre><pre class="pre codeblock leveled"><code>   proc calc_eff_par { enc_prop W L unit_length } {
    set scale_factor [ $unit_length ]
    set enc_list [ device::scaled_dfm_vec_measurements $enc_prop \
                     $scale_factor ]
    set accum 0.0
    set half_W [ expr { 0.5 * [$W] } ]
    foreach segment $enc_list {
      foreach { width length } $segment {
        set seg [ expr { ($width / ( $length + $half_W )) } ]
        set accum [ expr { $accum + $seg } ]
      }
    }
    return [ expr { $half_W - ( [$L] / $accum ) } ]
  }
*/]  

DEVICE MN ngate ngate(G) nsd(S) nsd(D) pwell(B)
DEVICE MP pgate pgate(G) psd(S) psd(D) nwell(B) </code></pre><p class="p">After running connectivity extraction with
the preceding code, you can run the Calibre Connectivity Interface
using the CCI command script shown in Example 1 as a starting template. </p>
</div>
<div class="section Subsection" id="id834a8436-ffb5-42a8-a234-19c777df4304__ide176c6c0-f3af-407c-8b56-4f87013a37ea"><h2 class="title Subheading sectiontitle">Expression Evaluation
Failures in DFM Property</h2><p class="p">When using DFM Property, it is important
to protect against <span class="ph FontProperty emphasis">expression evaluation failure</span>. Expression
evaluation failure occurs in any situation where DFM Property cannot
assign an appropriate property to polygons. Examples include numerical
errors, lookup of non-existent properties, out-of-range properties,
and so forth. Use of fall-through expressions in the DFM Property
operation to account for expressions that could lead to expression
evaluation failure is needed. </p>
<p class="p">See “<a class="xref Link" href="../../calbr_ver_user/nsmgchelp.htm" target="_top" onclick="oT('STD_FM11', 'DFM Property in ADP Device Recognition', 'calbr_ver_user'); return false;">DFM Property in ADP Device Recognition</a>” in the <cite class="cite">Calibre Verification
User’s Manual</cite> for a complete discussion.</p>
</div>
</div>
</div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent Topic:</strong> <a class="link" href="../topics/Contain_DeviceAnnotationBuiltInLanguage_id7f618268.html" title="The Device annotation built-in language is useful for MOS device well proximity and shallow trench isolation (STI) stress effect property calculations and similar applications. It is primarily used to extract physical parameters for the newer BSIM4 models.">Device Annotation Built-In Language</a></div>
</div>
</div></div>
</div>
<!--BeginFooterContent--><div class="BlankFooter" id="BlankFooter"> </div><div class="Footer" id="Footer"> </div><script type="text/javascript"><!--
                PDFLinkTitle = "InfoHub.Help"
                DocHandle = "svrf_ur"
                DocTitle = "Standard Verification Rule Format (SVRF) Manual"
                PageTitle = "Example Device Annotation Programs Using DFM Property"
                Copyright = "2021"
                ThisTopic = "PointingtoaCommoncustomerjsFile";
                CurrentFile = "topics/Concept_ExampleDeviceLayerAnnotateProgramsUsingDfmProperty_id834a8436.html"
                CurrentFileID = "3";
                topicFooter();
            --></script><noscript><p class="MGCFooter">Standard Verification Rule Format (SVRF) Manual, v2021.2<br />Unpublished work. © 2021 Siemens 
                <br /><a href="../../mgc_html_help/nsmgchelp.htm" target="_blank">Browser Requirements</a></p></noscript></body>
</html>